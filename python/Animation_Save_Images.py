#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""

This code simulates an expanding CME. 


**Important** This code only runs with the version of mathutil I uploaded to github because I had to
change code in mathutil.py (lines 215-217) for this to work. 


"""




import unittest
import numpy as np
import copy
from matplotlib import pyplot as plt
from astropy.io import fits
import pathlib
import scraytrace as sc


# ---- Define tests here


def test_CME():
    """Raytrace and display a GCS CM model"""
    
    imsize = [256, 256]
    modelid = 54
    # model parameters: see models51to60.cpp, CModel54::dumpDefaultParamForIDL
    # 
    # ("rb","2.55","dist to bottom of structure","Rsun"));    
    # ("alpha","0.52","angle between Oy and leg axis","rad"));    
    # ("h","6.","leg height","Rsun"));    
    # ("kappa","0.4","aspect ratio","")); 
    # ("nemin","1e6","Ne","cm^-3"));  
    # ("thick","0.1","Thickness of the skeleton axis.","Rsun"));
    # ("neaxis","0.","Electron density in the skeleton or axis","cm^-3"));
    # ("stiffness","0.","NOT USED",""));  
    # ("skinsigmain","0.1","inner sigma","")
        
    # ("skinsigmafr","0.1","front sigma",""));
    alpha = 0.53  #0.52
     #this is the time dependence
    kappa = 0.43 #0.4
    h=0.5
    modparam = [1.1, alpha, h, kappa, 1e6, 0.2, 0, 0.2, 0.2] #values correspond to description above. First value can be thought of as "time" - distance to sun - length of leg
    physics = 0
    DisttoSun_Rsun = 215. #distance to sun

    # compute CME leading edge height


    """


    Below this section is where I implement the animation loop.
    It begins by running the animation with the current value for h, and then after it runs, it
    chooses a new value of h for the next iteration.
    I chose an arbitrary 10 times to run it. I also chose to halve h through
    each iteration because, otherwise, the animation is too fast. """



    
    
    for i in range(20):

    
        leadingEdgeHeight = sc.model54_calcLeadingEdgeHeight(h, kappa, alpha) #This calculates the leading edge height

        rt = sc.scraytrace(imsize=imsize,
                        frontinteg=True,
                        losrange=[215-10, 215+10], #slice of space where we perform integration. If CME is outside region, will not integrate
                        losnbp=100, #How many points we sample for a slice. The more the better, but slower
                        modelid=modelid, 
                        modparam=modparam, 
                        physics=physics, 
                        fovpix=np.deg2rad(imsize[0] / imsize[0]), #FOV
                        projtypecode=1,
                        obsang=[0.,0,0],
                        obspos=[0., 0., -DisttoSun_Rsun], 
                        neang=np.deg2rad([30,220,0]), #How we orient CME in space
                        nbthreads=16, 
                        nbchunks=16,
                        phyparam=[0.4])

        rt.raytrace()
        
        palette = copy.copy(plt.cm.gray)
        palette.set_under(color='black')
        palette.set_bad(color='black')

        rt.dispim(cmap=palette, minmax=(1e-15, 1e-9))

        print("Leading edge height {0} Rsun".format(leadingEdgeHeight))


                #Below is where we set up the file saving part of the code

        foldername = ""
        for j in range(len(modparam)):
            if j != 2:
                foldername += str(modparam[j]) + "_"

        filename = '#' + str(i) + '_' +str(h) + '.fits'

        pathlib.Path('SCRaytrace_Output/' + foldername).mkdir(parents=True, exist_ok=True)
        
        hdu = fits.PrimaryHDU()
        hdul = fits.HDUList([hdu])
        hdu.writeto('SCRaytrace_Output/' + foldername + '/' + filename, overwrite=False)

        #Below is where we set a new modparam and h for the next iteration
        
        h = 1/2*sc.model54_calcLeadingEdgeHeight(h, kappa, alpha)
            
        modparam = [1.1, alpha, h, kappa, 1e6, 0.2, 0, 0.2, 0.2]


if __name__ == "__main__" :
    test_CME()


"""


Next Task:

Save the output into .fits file
Name the images so that we can read them later

Instead of 10, do 20 images - increase integration range

For a small movie, very important to save parameters we used for modelling - autogenerated .txt file in output folder

or .yaml file

Export modparam for each iteration

Do 4 or 5 sequences of CMEs with different parameters:

- neang  -[30,220,0] (towards earth), more or less all towards Earth [0,180,90]
- simulated image for coronagraphs
-

Creating artificial sequences of CME images




"""


        


    
